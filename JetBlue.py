# -*- coding: utf-8 -*-
"""Big Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qlnrYlrpI3nZ6qEO6OSVg4yrpP7W15ZG
"""

import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

home = '/content/drive/MyDrive'
#home = '/content/drive/MyDrive/lessons/Data Analytics/jetblue'

# exclude canceled flight.

df_flight = pd.read_csv(f'{home}/Flights.csv')
df_flight = df_flight[df_flight['CANCELLED'] != 1]

df_flight.head()

# Only considering "Roundtrip"
# RoundTrip = 1 : Round Trip

df_ticket = pd.read_csv(f'{home}/Tickets.csv')
df_ticket = df_ticket[df_ticket['ROUNDTRIP'] == 1]
df_ticket.head(10)

# Only Consideringt medium and large airport size.

df_airport_code = pd.read_csv(f'{home}/Airport_Codes.csv')
df_airport_code = df_airport_code[df_airport_code['TYPE'].isin(['medium_airport','large_airport'])]
print( df_airport_code )

"""## Explore Data

"""

df_flight.FL_DATE.unique()

df_ticket.PASSENGERS.unique()

df_flight.groupby(['ORIGIN', 'DESTINATION']).size().reset_index(name='Count').sort_values('Count', ascending=False)

df_ticket.groupby(['ORIGIN', 'DESTINATION']).agg({'PASSENGERS': ['count', 'sum']}).sort_values(('PASSENGERS', 'sum'), ascending=False)

"""Q1. The 10 busiest round-trip routes in terms of number of round-trip flights in the quarter. Exclude canceled flights when performing the calculation."""

busy_routes = df_flight.groupby(['ORIGIN', 'DESTINATION']).size().reset_index(name ='Count').sort_values(by = 'Count', ascending=False) # descending order
# busy_routes.head(10)
busy_routes.iloc[:10, :]

df_flight.shape

"""## Q2. The 10 most profitable round-trip routes (without considering the upfront airplane cost) in the quarter. Along with the profit, show total revenue, total cost, summary values of other key components and total round-trip flights in the quarter for the top 10 most profitable routes. Exclude canceled flights from these calculations."""

# Profit = Total Revenue - Total Cost

#REVENUE
#1. Ticket Price (Fare)
#2. Baggage Fee

# COST
#total cost
#1. maintenance cost
#2. operational cost
#3. arrival penalty
#4. departure penalty


df_flight['Capacity'] =df_flight['OCCUPANCY_RATE'] * 200 # Capacity by Flight
print(df_flight)

df_flight['baggage_fee'] = df_flight['Capacity'] * 329
df_flight

Capacities = df_flight.groupby(['ORIGIN', 'DESTINATION']).agg({'Capacity': ['sum', 'count']})
Capacities

Passengers = df_ticket.groupby(['ORIGIN', 'DESTINATION']).agg({'PASSENGERS': ['count', 'sum']}).sort_values(('PASSENGERS', 'sum'), ascending=False)
Passengers

Capacities.loc[(Capacities.index.get_level_values('ORIGIN') == 'JFK') & (Capacities.index.get_level_values('DESTINATION') == 'LAX')][('Capacity', 'sum')].item()

# Check if capacity < number of passengers
# WARNING: takes ~40seconds

for (origin, dest), row in Capacities.iterrows():
  capacity = row['Capacity']['sum']
  n_passengers = Passengers.loc[(Passengers.index.get_level_values('ORIGIN') == origin) & (Passengers.index.get_level_values('DESTINATION') == dest)][('PASSENGERS', 'sum')]

  if len(n_passengers) == 0:
    continue

  if capacity.item() < n_passengers.item():
    print(origin, dest, capacity, n_passengers)

# Departure Penalty

def departure_penalty(row):
  if row['DEP_DELAY'] < 15:
    return 0
  else:
    return (row['DEP_DELAY'] -15) * 75
df_flight['Departure_penalty']= df_flight.apply(departure_penalty, axis =1)
print(df_flight)

# Arrival Penalty

def arrival_penalty(row):
  if row['ARR_DELAY'] < 15:
    return 0
  else:
      return (row['ARR_DELAY'] -15 ) * 75

df_flight['Arrival_penalty']= df_flight.apply(arrival_penalty, axis =1)
print(df_flight)

import numpy as np

def maintenance_costs(row):
  if isinstance(row['DISTANCE'], float):
    return row.DISTANCE * (8 + 1.18)
  else:
    return 0

df_flight['maintenance_costs'] =df_flight.apply(maintenance_costs, axis =1)
df_flight

# IATA CODE(Airport) refers to airport or airline code.
# Origin & Destination 둘다에 Iata code 를 걸어서 medium 이랑 large airport 로 fileter 하기.
# Airport data 의 IATA code = flight 의 origin 이 같음.
# flight data & airport data 의 itacode 랑 type 으로  merge 시켜기.

with_origin_type = pd.merge(df_flight, df_airport_code[['IATA_CODE','TYPE']], left_on='ORIGIN', right_on='IATA_CODE')
with_origin_type = with_origin_type.rename(columns = {'TYPE':'ORIGIN_Type'})

with_type = pd.merge(with_origin_type, df_airport_code[['IATA_CODE','TYPE']], left_on='DESTINATION', right_on='IATA_CODE')
with_type = with_type.rename(columns = {'TYPE':'DEST_Type'})

with_type

with_type.columns

# Define a function to calculate cost based on airport type and distance
# Operational Cost

def operation_cost(row):
  origin_cost = 0
  dest_cost = 0

  if (row['ORIGIN_Type'] == 'medium_airport'):
    origin_cost = 5000
  elif (row['ORIGIN_Type'] == 'large_airport'):
    origin_cost = 10000

  if (row['DEST_Type']== 'medium_airport'):
    dest_cost = 5000
  elif (row['DEST_Type']== 'large_airport'):
    dest_cost = 10000

  return origin_cost + dest_cost

with_type['operation_cost'] = with_type.apply(operation_cost, axis=1)
with_type

with_type.columns

"""## Compute Cost by Routes"""

with_type['total_cost'] = with_type[['operation_cost', 'maintenance_costs', 'Departure_penalty', 'Arrival_penalty']].sum(axis=1)

cost_df = with_type.groupby(['ORIGIN', 'DESTINATION']).agg({'total_cost': ['sum', 'count']}).reset_index()

cost_df

"""##Comput Revenue by Routes"""

baggage_fee_df = with_type.groupby(['ORIGIN', 'DESTINATION']).agg({'baggage_fee': ['sum']}).reset_index()
baggage_fee_df

tickets_with_origin_type = pd.merge(df_ticket, df_airport_code[['IATA_CODE', 'TYPE']], left_on='ORIGIN', right_on='IATA_CODE')
tickets_with_origin_type = tickets_with_origin_type.rename(columns={'TYPE': 'ORIGIN_TYPE'})

tickets_with_type = pd.merge(tickets_with_origin_type, df_airport_code[['IATA_CODE', 'TYPE']], left_on='DESTINATION', right_on='IATA_CODE')
tickets_with_type = tickets_with_type.rename(columns={'TYPE': 'DEST_TYPE'})

tickets_with_type

tickets_with_type['ITIN_FARE'].astype(float)

with_type.columns

import re

tickets_with_type['ITIN_FARE'] = tickets_with_type['ITIN_FARE']

def only_take_numbers(x):
    target = re.findall(r'\d+', x) # \d+ : digits #+ : one or more occurence.
    if len(target) == 0:
        return 0
    return float(target[0])

# Assuming you have a DataFrame named tickets_with_type with the 'ITIN_FARE' and 'PASSENGERS' columns

# Apply the only_take_numbers function to 'ITIN_FARE' column and create 'itin_fare_parsed' column
tickets_with_type['itin_fare_parsed'] = tickets_with_type['ITIN_FARE'].astype(str).apply(only_take_numbers)

# Calculate 'ticket_price' by multiplying 'itin_fare_parsed' with 'PASSENGERS' column
tickets_with_type['ticket_price'] = tickets_with_type['itin_fare_parsed'] * tickets_with_type['PASSENGERS']

# To check if there is unexpected data
tickets_with_type[(tickets_with_type['ticket_price'] == 0) & (tickets_with_type['ITIN_FARE'] != '0.0')]['ITIN_FARE'].unique()

itin_fare_df = tickets_with_type.groupby(['ORIGIN', 'DESTINATION']).agg({'ticket_price': ['sum']}).reset_index()
itin_fare_df

revenue_cost = pd.merge(pd.merge(cost_df, baggage_fee_df, on=['ORIGIN', 'DESTINATION']), itin_fare_df, on=['ORIGIN', 'DESTINATION'])
revenue_cost.columns = ['{}_{}'.format(col[0], col[1]) for col in revenue_cost.columns]
revenue_cost

revenue_cost['profit'] = revenue_cost['baggage_fee_sum'] + revenue_cost['ticket_price_sum'] - revenue_cost['total_cost_sum']
q2_df = revenue_cost.sort_values('profit', ascending=False).iloc[:10, :]
q2_df

# Check change in baggage fee

#q2_df['baggage_fee_sum'] = q2_df['baggage_fee_sum'] * 4
#q2_df['baggage_fee_sum']

print("The 10 most profitable round-trip routes are\n")
count = 1
print("Rank\tRoute\t\tProfit")
for i, row in q2_df.iterrows():
  print(f"{count}\t{row['ORIGIN_']}-{row['DESTINATION_']}\t\t{row['profit']:,.2f}")
  count += 1

"""##3. The 5 round trip routes that you recommend investing in based on any factors that you choose.

## Total Revenue, Total Cost, Summary Values
"""

total_cost = revenue_cost['total_cost_sum'].sum()
total_revenue = (revenue_cost['baggage_fee_sum'] + revenue_cost['ticket_price_sum']).sum()

print("total cost is: ", total_cost )
print("total revenue is : ", total_revenue)

total_profit = (q2_df['profit']).sum()
print("\nTotal Profit is : ", total_profit)

"""## Recommendation on a certain factor."""

# 요일별로 groupby 해서 비교

grouped_flights = new_dat.groupby(['FL_DATE','ORIGIN_AIRPORT_ID', 'DEST_AIRPORT_ID']).size()
grouped_flights

import matplotlib.pyplot as plt
import matplotlib.dates as mdates

# Group the data by 'FL_DATE', 'ORIGIN_AIRPORT_ID', and 'DEST_AIRPORT_ID' and calculate the size
grouped_data = new_dat.groupby(['FL_DATE', 'ORIGIN_AIRPORT_ID', 'DEST_AIRPORT_ID']).size().reset_index(name='Count')

# Convert 'FL_DATE' to datetime type
grouped_data['FL_DATE'] = pd.to_datetime(new_dat['FL_DATE'])

# Group the data by date only
grouped_data['Date'] = grouped_data['FL_DATE'].dt.strftime('%m/%d/%Y')

# Group the data by 'Date', 'ORIGIN_AIRPORT_ID', and 'DEST_AIRPORT_ID' and calculate the sum of counts
grouped_data = grouped_data.groupby(['Date', 'ORIGIN_AIRPORT_ID', 'DEST_AIRPORT_ID']).sum().reset_index()

# Set 'Date' as the index
grouped_data.set_index('Date', inplace=True)

# Create a figure and axis for the plot
fig, ax = plt.subplots(figsize=(12, 6))

# Convert flight dates to numeric values
flight_dates = pd.to_datetime(grouped_data.index).map(mdates.date2num)

# Plot the bar graph
ax.bar(flight_dates, grouped_data['Count'], align='center', alpha=0.5)

# Set x-axis formatter to display dates as numeric values
date_format = mdates.DateFormatter('%Y-%m-%d')
ax.xaxis.set_major_formatter(date_format)

# Set labels and title
ax.set_xlabel('Flight Date')
ax.set_ylabel('Count')
ax.set_title('Flight Count by Origin and Destination on Different Dates')

# Show the plot
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Group the data by 'FL_DATE', 'ORIGIN_AIRPORT_ID', and 'DEST_AIRPORT_ID' and calculate the size
grouped_data = new_dat.groupby(['FL_DATE', 'ORIGIN_AIRPORT_ID', 'DEST_AIRPORT_ID']).size().reset_index(name='Count')

# Create a figure and axis for the plot
fig, ax = plt.subplots(figsize=(12, 6))

# Plot the bar graph
ax.bar(grouped_data['FL_DATE'], grouped_data['Count'], align='center', alpha=0.5)

# Set x-axis tick labels to the flight dates and rotate them for better readability
ax.set_xticklabels(grouped_data['FL_DATE'].dt.strftime('%Y-%m-%d'), rotation=90)

# Set labels and title
ax.set_xlabel('Flight Date')
ax.set_ylabel('Count')
ax.set_title('Flight Count by Origin and Destination on Different Dates')

# Show the plot
plt.tight_layout()
plt.show()

grouped_data.groupby(grouped_data.index).size()

new_dat.groupby(['TYPE']).size()

ticket_df = pd.read_csv('Tickets.csv', header=0)
ticket_df.head()

# Eeach bar represents the count of tickets or flights for a specific flight route (combination of origin city and destination city).
# The x-axis labels will display the flight routes, and the height of each bar represents the corresponding count value.


import matplotlib.pyplot as plt

# Group the data by 'ORIGIN_CITY_NAME' and 'DEST_CITY_NAME' and calculate the size
grouped_data = df_notcanceled.groupby(['ORIGIN_CITY_NAME', 'DEST_CITY_NAME']).size().reset_index(name='Count')

# Sort the grouped data by count in descending order
grouped_data.sort_values('Count', ascending=False, inplace=True)

# Create a figure and axis for the plot
fig, ax = plt.subplots(figsize=(12, 6))

# Plot the bar graph
x_ticks = grouped_data['ORIGIN_CITY_NAME'] + ' to ' + grouped_data['DEST_CITY_NAME']
ax.bar(range(len(x_ticks)), grouped_data['Count'], align='center', alpha=0.5)

# Set x-axis tick labels
ax.set_xticks(range(len(x_ticks)))
ax.set_xticklabels(x_ticks, rotation=90)

# Set labels and title
ax.set_xlabel('Route')
ax.set_ylabel('Count')
ax.set_title('Flight Ticket Count by Route')

# Show the plot
plt.tight_layout()
plt.show()

# Find the index of the row with the maximum count
max_index = grouped_data['Count'].argmax()

# Get the corresponding values of 'ORIGIN_CITY_NAME' and 'DEST_CITY_NAME'
max_origin_city = grouped_data.loc[max_index, 'ORIGIN_CITY_NAME']
max_dest_city = grouped_data.loc[max_index, 'DEST_CITY_NAME']

# Print the result
print(f"The route with the greatest count is {max_origin_city} to {max_dest_city}")

# Assuming you have a DataFrame named 'grouped_data' with columns 'Count', 'ORIGIN_CITY_NAME', and 'DEST_CITY_NAME'

# Find the top 10 indices of rows with the maximum count
top_indices = grouped_data['Count'].nlargest(10).index

# Get the corresponding values of 'ORIGIN_CITY_NAME' and 'DEST_CITY_NAME' for the top indices
top_origin_cities = grouped_data.loc[top_indices, 'ORIGIN_CITY_NAME']
top_dest_cities = grouped_data.loc[top_indices, 'DEST_CITY_NAME']

# Print the top 10 routes with the greatest count
for i, (origin_city, dest_city) in enumerate(zip(top_origin_cities, top_dest_cities), 1):
    print(f"Route {i}: {origin_city} to {dest_city}")

"""##4. Break Even point"""

# Assuming you have a DataFrame named 'grouped_data' with columns 'Count', 'ORIGIN_CITY_NAME', and 'DEST_CITY_NAME'

# Find the top 10 indices of rows with the maximum count
top_indices = grouped_data['Count'].nlargest(10).index

# Filter and process only the top 10 rows
for index in top_indices:
    row = grouped_data.loc[index]
    origin_city = row['ORIGIN_CITY_NAME']
    dest_city = row['DEST_CITY_NAME']
    count = row['Count']

    # Process the row as desired
    print(f"Processing row {index}: {origin_city} to {dest_city} with count {count}")

breakeven_newgroup = df_notcanceled.groupby(['ORIGIN_CITY_NAME','DEST_CITY_NAME','DISTANCE', 'DEP_DELAY', 'ARR_DELAY']).size().reset_index(name='count')
print(breakeven_newgroup)

top_indices = breakeven_newgroup['count'].nlargest(10).index
for index in top_indices:
    origin_city = breakeven_newgroup.loc[index, 'ORIGIN_CITY_NAME']
    dest_city = breakeven_newgroup.loc[index, 'DEST_CITY_NAME']
    distance = breakeven_newgroup.loc[index,'DISTANCE']
    departure_delay = breakeven_newgroup.loc[index, 'DEP_DELAY']
    arrival_delay = breakeven_newgroup.loc[index, 'ARR_DELAY']


    print(f"Route: {origin_city} to {dest_city}")
    print(f"Distance: {distance}")
    print(f"Departure Delay: {departure_delay}")
    print(f"Arrival Delay: {arrival_delay}")
    print()

import pandas as pd

# Assuming you have two DataFrames named 'flights_df' and 'ticket_df'

# Perform a left join on the common column
revenue_merged = pd.merge(df_notcanceled , df_roundtrip [['DESTINATION', 'ITIN_FARE']], on='DESTINATION', how='left')

# Calculate revenue using the 'ITIN_FARE' column
revenue_merged['revenue'] = (200 * 70 / 2) + revenue_merged['ITIN_FARE']

# Display the first few rows of the merged DataFrame
print(revenue_merged.head())

import pandas as pd

# Assuming you have two DataFrames named 'flights' and 'tickets'

# Perform a left join on the 'DESTINATION' column
merged_data = pd.merge(flights_df, ticket_df[['DESTINATION', 'ITIN_FARE']], on='DESTINATION', how='left')

# Display the merged DataFrame
print(merged_data.head())

# Step 7: Calculate and print the breakeven point for each row
for index, row in breakeven_newgroup.iterrows():
    # Extract the necessary data from the "breakeven_newgroup" dataset
    distance = row['DISTANCE']
    departure_delay = row['DEP_DELAY']
    arrival_delay = row['ARR_DELAY']

    # Calculate the cost
    cost = 9.18 * distance + 75 * departure_delay + 75 * arrival_delay

    # Find the corresponding ticket price from the "Ticket" dataset based on the index
    ticket_price = ticket_df.loc[index, 'ITIN_FARE']

    # Calculate the revenue
    revenue = ((200 * 70) / 2) + renvenue_merged['ITIN_FARE']

    # Calculate the breakeven point
    breakeven_point = cost - revenue

    print(f"Breakeven point for row {index}: {breakeven_point}")